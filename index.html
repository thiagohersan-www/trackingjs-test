<!doctype html>
<html>
  <head>

    <title>tracking.js - match patterns</title>

    <meta charset="utf-8">

    <script src="node_modules/tracking/build/tracking-min.js"></script>
    <script src="node_modules/dat.gui/build/dat.gui.min.js"></script>

    <style>
      .image-template {
        position: absolute;
        left: -1000px;
        top: -1000px;
      }
      #video {
        position: absolute;
        top: -1000px;
      }
    </style>
  </head>
  <body>
    <div class="canvas-container">
      <video id="video" width="640" height="360" preload autoplay loop muted controls></video>
      <canvas id="canvas" width="720" height="720"></canvas>
    </div>

    <script>
      window.onload = function() {
        navigator.getUserMedia = navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia;

        const cards = [
          { imageFile: 'tarot00.jpg', profile: 'scandal'},
          { imageFile: 'tarot01.jpg', profile: 'smash hit'},
          { imageFile: 'tarot02.jpg', profile: 'mother nature'},
          { imageFile: 'tarot03.jpg', profile: 'radio star'},
          { imageFile: 'tarot04.jpg', profile: 'siren'},
          { imageFile: 'tarot05.jpg', profile: 'bffs'},
          { imageFile: 'tarot06.jpg', profile: 'super fan'},
          { imageFile: 'tarot07.jpg', profile: 'big bad wolf'},
          { imageFile: 'tarot08.jpg', profile: 'forgotten'},
          { imageFile: 'tarot09.jpg', profile: 'service dog'},
          { imageFile: 'tarot10.jpg', profile: 'catalyst'},
          { imageFile: 'tarot11.jpg', profile: 'backstabber'}
        ];

        var populateImages = function() {
          const container = document.getElementsByClassName('canvas-container')[0];

          for(let i=0; i<cards.length; i++) {
            const image = document.createElement('img');
            image.classList.add('image-template');
            image.setAttribute('id', cards[i].imageFile.replace('.jpg', ''));
            image.setAttribute('src', 'imgs/' + cards[i].imageFile);
            container.appendChild(image);
          }
        }
        populateImages();

        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const images = document.getElementsByClassName('image-template');
        const video = document.getElementById('video');
        const templateWidth = 240;
        const templateHeight = 368;
        const videoWidth = 640;
        const videoHeight = 360;
        const corners = [];
        const descriptors = [];
        let isRunning = false;

        window.descriptorLength = 256;
        window.blurRadius = 1.01;

        var getCornerDescriptors = function() {
          tracking.Brief.N = window.descriptorLength;

          for(let i=0; i<images.length; i++) {
            context.drawImage(images[i], 0, 0, templateWidth, templateHeight);
            const imageData = context.getImageData(0, 0, templateWidth, templateHeight);
            const gray = tracking.Image.grayscale(tracking.Image.blur(imageData.data, templateWidth, templateHeight, window.blurRadius), templateWidth, templateHeight);
            const mCorners = tracking.Fast.findCorners(gray, templateWidth, templateHeight);
            const mDescriptors = tracking.Brief.getDescriptors(gray, templateWidth, mCorners);
            corners.push(mCorners);
            descriptors.push(mDescriptors);
            context.clearRect(0, 0, canvas.width, canvas.height);
          }
        }
        getCornerDescriptors();

        var debugCorners = function() {
          for(let j=0; j<images.length; j++) {
            context.drawImage(images[j],
                              j*templateWidth, 0, templateWidth, templateHeight);
            for(let i=0; i<corners[j].length; i+=2) {
              context.fillStyle = '#f00';
              context.fillRect(corners[j][i] + j*templateWidth,
                               corners[j][i + 1], 3, 3);
            }
          }
        }
        debugCorners();

        var TarotTracker = function() {
          TarotTracker.base(this, 'constructor');
        }
        tracking.inherits(TarotTracker, tracking.Tracker);

        TarotTracker.prototype.templateDescriptors_ = null;
        TarotTracker.prototype.templateKeypoints_ = null;
        TarotTracker.prototype.fastThreshold = 80;
        TarotTracker.prototype.blur = window.blurRadius;

        TarotTracker.prototype.setTemplate = function() {
          this.templateKeypoints_ = corners[0];
          this.templateDescriptors_ = descriptors[0];
        };

        TarotTracker.prototype.track = function(pixels, mWidth, mHeight) {
          const frameBlur = tracking.Image.blur(pixels, mWidth, mHeight, window.blurRadius);
          const frameGrayscale = tracking.Image.grayscale(frameBlur, mWidth, mHeight);
          const frameKeypoints = tracking.Fast.findCorners(frameGrayscale, mWidth, mHeight, this.fastThreshold);
          const frameDescriptors = tracking.Brief.getDescriptors(frameGrayscale, mWidth, frameKeypoints);

          const matchResults = [];
          for(let i=0; i<descriptors.length; i++) {
            const recMatch = tracking.Brief.reciprocalMatch(corners[i], descriptors[i],
                                                            frameKeypoints, frameDescriptors);
            recMatch.sort(function(a, b) {
              return b.confidence - a.confidence;
            });

            let confidenceSum = 0;
            for(let j=0; j<recMatch.length; j++){
              confidenceSum += recMatch[j].confidence;
            }

            if(recMatch.length > 0){
              matchResults.push({
                match: recMatch,
                length: recMatch.length,
                confidence: confidenceSum/recMatch.length
              });
            } else{
              matchResults.push({
                match: [],
                length: 0,
                confidence: 0
              });
            }
          }
          console.log(matchResults);

          // TODO: return best match
          // best match := highest confidence AND also highest number of points
          // OR
          // best match := highest confidence larger than (next-highest + Îµ)
          this.emit('track', {
            data: matchResults[0].match
          });
        };

        const tracker = new TarotTracker();
        tracker.on('track', function(event) {

          context.clearRect(0, 0, canvas.width, canvas.height);
          context.drawImage(video, 0, 0, videoWidth, videoHeight);

          // Plots matching points on canvas
          for (let i = 0; i < Math.min(100, event.data.length); i++) {
            const template = event.data[i].keypoint1;
            const frame = event.data[i].keypoint2;
            context.fillStyle = '#f00';
            context.fillRect(frame[0], frame[1], 3, 3);
          }
        });

        const vidParams = {
          width: videoWidth,
          height: videoHeight
        };

        navigator.getUserMedia({video: vidParams}, function(stream) {
          var mVideo = document.getElementById('video');
          mVideo.srcObject = stream;
          mVideo.onloadedmetadata = function(e) {
            mVideo.play();
          };
        }, function(err) {
          alert(err.name);
          console.log("The following error occurred in getUserMedia: " + err.name);
        });

        const trackerTask = tracking.track('#video', tracker, { camera: true });
        trackerTask.stop();
        document.getElementById('canvas').addEventListener('click', function() {
          if(isRunning) {
            trackerTask.stop();
            isRunning = false;
          } else {
            tracker.setTemplate();
            trackerTask.run();
            isRunning = true;
          }
        });
      }
    </script>

  </body>
</html>
